<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="qryBeleg.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <metadata name="$this.TrayHeight" type="System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>57</value>
  </metadata>
  <data name="qryBeleg.SelectStatement" xml:space="preserve">
    <value>DECLARE @Auszahlungsart INT;
DECLARE @nurKantFonds BIT;
DECLARE @nurCHFonds BIT;

---SET @Auszahlungsart = {edtAuszahlungsart};
---SET @nurKantFonds = {chkNurKantonaleFonds};
---SET @nurCHFonds = {chkNurCHFonds};

DECLARE @LanguageCode INT;
SET @LanguageCode = {2};

;WITH OrgUnitCTE AS
(
  SELECT
    ORG.OrgUnitID,
    ORG.ParentID
  FROM dbo.XOrgUnit ORG WITH (READUNCOMMITTED)
  WHERE ORG.Mandantennummer = ISNULL({3}, ORG.Mandantennummer)

  UNION ALL

  SELECT
    ORG.OrgUnitID,
    ORG.ParentID
  FROM dbo.XOrgUnit       ORG WITH (READUNCOMMITTED)
    INNER JOIN OrgUnitCTE CTE ON CTE.OrgUnitID = ORG.ParentID  --Wir suchen inkl. aller Sub-OrgUnits
)

SELECT BUC.KbBuchungID,
       BUC.KbPeriodeID,
       KbBuchungStatusCode = CASE WHEN BUC.KbBuchungStatusCode IS NOT NULL THEN BUC.KbBuchungStatusCode
                                  WHEN GAP.GvAuszahlungPositionStatusCode = 5 /*Bewilligung erteilt*/ THEN 2 /*Freigegeben*/
                             END,
       BUC.BelegNr,
       BUC.BelegDatum,
       GAP.GvAuszahlungPositionID,
       GES.GvGesuchID,
       GAP.ValutaDatum,
       GAP.Betrag,
       KlientIn = PRS.NameVorname,
       Buchungstext = REPLACE(
                        REPLACE(dbo.fnGetMLTextFromName('BelegimportAusGesuchverwaltung', 'Buchungstext', @LanguageCode), {0}, KRE.Kreditor),
                        {1},
                        ISNULL(CONVERT(VARCHAR(MAX), GAP.ValutaDatum, 104),
                          STUFF(
                            (SELECT ', ' + CONVERT(VARCHAR, VAL.Datum, 104)
                             FROM dbo.GvAuszahlungPositionValuta VAL
                             WHERE VAL.GvAuszahlungPositionID = GAP.GvAuszahlungPositionID
                             ORDER BY VAL.Datum
                             FOR XML PATH('')),
                            1, 2, ''))),
       KRE.Kreditor,
       GAP.Referenznummer,
       BUC.ErstelltUserID
FROM dbo.GvAuszahlungPosition       GAP 
  INNER JOIN dbo.GvGesuch           GES ON GES.GvGesuchID = GAP.GvGesuchID
  INNER JOIN dbo.GvFonds            FND ON GES.GvFondsID = FND.GvFondsID
  INNER JOIN dbo.vwPerson           PRS ON PRS.BaPersonID = GES.BaPersonID
  INNER JOIN dbo.vwKreditor         KRE ON KRE.BaZahlungswegID = GAP.BaZahlungswegID
  LEFT  JOIN dbo.KbKonto            KTO ON KTO.KbZahlungskontoID = FND.KbZahlungskontoID
                                       AND KTO.KbPeriodeID = {4}
  LEFT  JOIN dbo.KbBuchungKostenart KBK ON KBK.GvAuszahlungPositionID = GAP.GvAuszahlungPositionID
  LEFT  JOIN dbo.KbBuchung          BUC ON BUC.KbBuchungID = KBK.KbBuchungID   
  LEFT  JOIN dbo.KbPeriode          PER ON PER.KbPeriodeID = BUC.KbPeriodeID
WHERE 1 = 1
  AND GAP.GvAuszahlungPositionStatusCode = 5 --5: Bewilligung erteilt
  AND IsNull(BUC.KbBuchungStatusCode, 5) = 5 --5: ZahlauftragFehlerhaft
  AND (@Auszahlungsart &lt;&gt; 101 OR KTO.KbKontoID IS NOT NULL) -- Zahlungskonto muss für elektronische Zahlungen vorhanden sein
  AND GAP.GvAuszahlungArtCode = @Auszahlungsart
  AND (@nurKantFonds = 0 OR FND.IstCH = 0) -- nur Kantonalischen Fonds ? RAT 9690
  AND (@nurCHFonds=0 OR FND.IstCH = 1) -- nur Schweiz. Fonds ? RAT 9690
---  AND dbo.fnDateOf(GAP.ValutaDatum) &gt;= {edtSucheValutaVon}
---  AND dbo.fnDateOf(GAP.ValutaDatum) &lt;= {edtSucheValutaBis}
---  AND BUC.BelegNr &gt;= {edtSucheBelegNrVon}
---  AND BUC.BelegNr &lt;= {edtSucheBelegNrBis}
---  AND BUC.ErstelltUserID = {edtSucheBelegErsteller.LookupID}
---  AND (',' + {edtSucheKbBuchungsStatus} + ',' LIKE '%,' + CONVERT(VARCHAR, BUC.KbBuchungStatusCode) + ',%')
AND EXISTS (SELECT TOP 1 LEI.FaLeistungID, LEI.UserID
            FROM dbo.FaLeistung             LEI WITH (READUNCOMMITTED)
              INNER JOIN dbo.XOrgUnit_User  OUU WITH (READUNCOMMITTED) ON LEI.UserID = OUU.UserID
                                                                      AND OUU.OrgUnitMemberCode = 2 --2: Mitglied
              INNER JOIN OrgUnitCTE         CTE ON CTE.OrgUnitID = OUU.OrgUnitID
            WHERE LEI.BaPersonID = GES.BaPersonID
              AND LEI.ModulID = 2)
</value>
  </data>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="edtBelegDatum.Properties.Buttons" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAAAwAAAAQCAYAAAAiYZ4HAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8
        YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABMSURBVDhPYwABY2Pj/8RgsGIQgHFQBKEAqxyIQwyGKsdu
        MjrAqaGhgQErG6sGkAKYInSaOhpAYERrAAFkNk4NuACGBmIwVDkpgIEBAO2ojyYwtBe7AAAAAElFTkSu
        QmCC
</value>
  </data>
  <data name="edtSucheValutaBis.Properties.Buttons" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAAAwAAAAQCAYAAAAiYZ4HAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8
        YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABMSURBVDhPYwABY2Pj/8RgsGIQgHFQBKEAqxyIQwyGKsdu
        MjrAqaGhgQErG6sGkAKYInSaOhpAYERrAAFkNk4NuACGBmIwVDkpgIEBAO2ojyYwtBe7AAAAAElFTkSu
        QmCC
</value>
  </data>
  <data name="edtSucheValutaVon.Properties.Buttons" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAAAwAAAAQCAYAAAAiYZ4HAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8
        YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABMSURBVDhPYwABY2Pj/8RgsGIQgHFQBKEAqxyIQwyGKsdu
        MjrAqaGhgQErG6sGkAKYInSaOhpAYERrAAFkNk4NuACGBmIwVDkpgIEBAO2ojyYwtBe7AAAAAElFTkSu
        QmCC
</value>
  </data>
  <metadata name="qrySucheKGS.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>116, 17</value>
  </metadata>
  <data name="qrySucheKGS.SelectStatement" xml:space="preserve">
    <value>DECLARE @ZahlungskontoUndGruppeEingeschraenkt BIT;
DECLARE @AlleGruppen BIT;
DECLARE @UserID INT;

SET @ZahlungskontoUndGruppeEingeschraenkt = {0}; -- Config-Value ZahlungskontoUndGruppeEingeschraenkt
SET @AlleGruppen = {1}; -- User has Spezialrecht AlleGruppen
SET @UserID = {2};

SELECT
  [Code]     = NULL,
  [Text]     = ''

UNION ALL

SELECT
  [Code]      = ORG.Mandantennummer,
  [Text]      = CONVERT(VARCHAR(10), ISNULL(ORG.Mandantennummer, -1)) + '   ' + ORG.ItemName
FROM dbo.XOrgUnit ORG WITH (READUNCOMMITTED)
WHERE ORG.Mandantennummer IS NOT NULL                      
  AND (@ZahlungskontoUndGruppeEingeschraenkt = 0 OR @AlleGruppen = 1)
ORDER BY [Code], [Text];</value>
  </data>
</root>