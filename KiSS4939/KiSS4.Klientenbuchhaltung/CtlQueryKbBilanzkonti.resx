<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="qryQuery.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <data name="qryQuery.SelectStatement" xml:space="preserve">
    <value>DECLARE @KbPeriodeID INT;
SET @KbPeriodeID = {0}; -- KbPeriodeID aus FormKlibu (FormController)

DECLARE @auchUnverbuchte BIT;
--- SET @auchUnverbuchte = {edtAuchUnverbuchte};

DECLARE @datumVon DATETIME;
--- SET @datumVon = {edtDatumVonX};
--- SET @datumVon = {edtBezahltAmX};


DECLARE @VorsaldoDatum DATETIME;
SET @VorsaldoDatum = DATEADD(DAY, -1, @datumVon);

DECLARE @vorsaldo TABLE 
(
  KbKontoID INT NOT NULL,
  Vorsaldo MONEY NOT NULL
);

INSERT INTO @vorsaldo
  SELECT KbKontoID,
         Vorsaldo = dbo.fnKbGetKontoVorsaldo(KTO.KbPeriodeID, KTO.KontoNr, @datumVon, @auchUnverbuchte)
  FROM dbo.KbKonto KTO WITH (READUNCOMMITTED)
  WHERE KTO.KbPeriodeID = @KbPeriodeID
--- AND KTO.KbKontoID = {edtKontoX.LookupID}
   AND KTO.KbKontoklasseCode IN (5, 6);

IF (OBJECT_ID('TempDB.dbo.#Temp') IS NOT NULL)
BEGIN 
  DROP TABLE #Temp;
END;

CREATE TABLE #Temp 
(
  ID INT NOT NULL IDENTITY(1,1) PRIMARY KEY,
  KbBuchungID INT,
  KontoNr VARCHAR(10),
  KontoName VARCHAR(100),
  BetragSoll MONEY,
  BetragHaben MONEY,
  Betrag MONEY,
  BaPersonID$ INT,
  SollKontoNr VARCHAR(MAX),
  SollKonto VARCHAR(MAX),
  HabenKontoNr VARCHAR(MAX),
  HabenKonto VARCHAR(MAX),
  BelegNr INT,
  Datum DATETIME,
  ValutaDatum DATETIME,
  Buchungtext VARCHAR(200),
  Mitarbeiter VARCHAR(200),
  Gegenkonto VARCHAR(MAX),
  Kostenart VARCHAR(MAX),
  Kostenstelle VARCHAR(MAX),
  Vorsaldo MONEY,
  Verbucht BIT,
  Ausgeglichen BIT,
  KbZahlungseingangID INT
);

;WITH TempCteBuc AS
(
  SELECT
    KbBuchungID  = BUC.KbBuchungID,
    KontoNr      = KTO.KontoNr,
    KontoName    = KTO.KontoNr + ' ' + KTO.KontoName,
    BetragSoll   = CASE
                     WHEN BUC.SollKtoNr = KTO.KontoNr OR (BUC.SollKtoNr IS NULL AND ISNULL(KOA.KontoNr, BGK.KontoNr) = KTO.KontoNr)
                       THEN ISNULL(KOA.Betrag, BUC.Betrag)
                     ELSE 0.0
                   END,
    BetragHaben  = CASE
                     WHEN BUC.HabenKtoNr = KTO.KontoNr OR (BUC.HabenKtoNr IS NULL AND ISNULL(KOA.KontoNr, BGK.KontoNr) = KTO.KontoNr)
                       THEN ISNULL(KOA.Betrag, BUC.Betrag)
                     ELSE 0.0
                   END,
    Betrag       = ISNULL(KOA.Betrag, BUC.Betrag),
    BaPersonID$  = KOA.BaPersonID,
    SollKontoNr  = ISNULL(BUC.SollKtoNr, KOA.KontoNr),
    SollKonto    = (SELECT TOP 1 KTS.KontoName
                    FROM dbo.KbKonto KTS WITH(READUNCOMMITTED)
                    WHERE KTS.KbPeriodeID = BUC.KbPeriodeID
                      AND (KTS.KontoNr = BUC.SollKtoNr
                        OR KTS.KontoNr = KOA.KontoNr)),
    HabenKontoNr = COALESCE(BUC.HabenKtoNr, BGK.KontoNr, NULL),
    HabenKonto   = (SELECT TOP 1 KTH.KontoName
                    FROM dbo.KbKonto KTH WITH(READUNCOMMITTED)
                    WHERE KTH.KbPeriodeID = BUC.KbPeriodeID
                      AND (KTH.KontoNr = BUC.HabenKtoNr OR (BUC.HabenKtoNr IS NULL AND BGK.KontoNr = KTO.KontoNr))),
    BelegNr      = BUC.BelegNr,
    Datum        = BUC.BelegDatum,
    ValutaDatum  = BUC.ValutaDatum,
    Buchungtext  = BUC.[Text],
    Mitarbeiter  = USR.LogonName,
    Gegenkonto   = BGK.KontoNr,
    Kostenart    = BGK.Name,
    Kostenstelle = NULL,
    Vorsaldo     = VOR.Vorsaldo,
    Verbucht     = ISNULL(ZEG.Ausgeglichen, CONVERT(BIT, 1)),
    Ausgeglichen = CASE 
                     WHEN ZEG.KbZahlungseingangID IS NULL THEN CONVERT(BIT, 0)
                     WHEN ZEG.Ausgeglichen = 1
                       OR ZEG.Betrag = (SELECT SUM(BUC.Betrag)
                                        FROM dbo.KbBuchung BUC WITH (READUNCOMMITTED)
                                        WHERE BUC.KbZahlungseingangID = ZEG.KbZahlungseingangID)
                     THEN CONVERT(BIT, 1)
                     ELSE CONVERT(BIT, 0)
                   END,
    KbZahlungseingangID = ZEG.KbZahlungseingangID
  FROM dbo.KbKonto                    KTO WITH(READUNCOMMITTED)
    INNER JOIN @vorsaldo              VOR                       ON VOR.KbKontoID = KTO.KbKontoID
    INNER JOIN dbo.KbBuchung          BUC WITH(READUNCOMMITTED) ON BUC.KbPeriodeID = KTO.KbPeriodeID
                                                               AND BUC.BelegNr IS NOT NULL
                                                               AND BUC.BelegDatum IS NOT NULL
    LEFT  JOIN dbo.KbBuchungKostenart KOA WITH(READUNCOMMITTED) ON BUC.KbBuchungID = KOA.KbBuchungID
    INNER JOIN dbo.XUser              USR WITH(READUNCOMMITTED) ON USR.UserID = BUC.ErstelltUserID
    LEFT  JOIN dbo.BgKostenart        BGK WITH(READUNCOMMITTED) ON BGK.BgKostenartID = KOA.BgKostenartID
    LEFT  JOIN dbo.KbZahlungseingang  ZEG WITH(READUNCOMMITTED) ON ZEG.KbZahlungseingangID = BUC.KbZahlungseingangID
  WHERE KTO.KbPeriodeID = @KbPeriodeID
    AND KTO.KbKontoklasseCode IN (5,6)
    AND (BUC.SollKtoNr = KTO.KontoNr
      OR BUC.HabenKtoNr = KTO.KontoNr
      OR KOA.KontoNr = KTO.KontoNr
      OR BGK.KontoNr = KTO.KontoNr)
--- AND dbo.fnDateOf(BUC.BelegDatum) &gt;= {edtDatumVonX}
--- AND dbo.fnDateOf(BUC.BelegDatum) &lt;= {edtDatumBisX}
--- AND KTO.KbKontoID = {edtKontoX.LookupID}
--- AND dbo.fnDateOf(BUC.BelegDatum) = {edtBezahltAmX}
)

INSERT INTO #Temp
  SELECT
    KbBuchungID  = KbBuchungID,
    KontoNr      = KontoNr,
    KontoName    = KontoName,
    BetragSoll   = SUM(BetragSoll),
    BetragHaben  = SUM(BetragHaben),
    Betrag       = SUM(Betrag),
    BaPersonID$  = NULL,
    SollKontoNr  = dbo.ConcDistinct(SollKontoNr),
    SollKonto    = dbo.ConcDistinct(SollKonto),
    HabenKontoNr = dbo.ConcDistinct(HabenKontoNr),
    HabenKonto   = dbo.ConcDistinct(HabenKonto),
    BelegNr      = BelegNr,
    Datum        = Datum,
    ValutaDatum  = ValutaDatum,
    Buchungtext  = Buchungtext,
    Mitarbeiter  = Mitarbeiter,
    Gegenkonto   = dbo.ConcDistinct(Gegenkonto),
    Kostenart    = dbo.ConcDistinct(Kostenart),
    Kostenstelle = NULL,
    Vorsaldo     = Vorsaldo,
    Verbucht     = Verbucht,
    Ausgeglichen = Ausgeglichen,
    KbZahlungseingangID = KbZahlungseingangID
  FROM TempCteBuc CTE
  GROUP BY CTE.KbBuchungID, CTE.KontoNr, CTE.KontoName, CTE.BelegNr, CTE.Datum, CTE.ValutaDatum, CTE.Buchungtext, CTE.Mitarbeiter, CTE.Vorsaldo, CTE.Verbucht, CTE.Ausgeglichen, CTE.KbZahlungseingangID;

CREATE NONCLUSTERED INDEX [IX_#Temp_KbBuchungID] ON #Temp 
(
  [KbBuchungID] ASC
);

-- COLLATE DATABASE_DEFAULT ist bei VARCHAR-Spalten wegen CAR und SRK notwendig (Collation zwischen den Server und die DB ist unterschiedlich)
;WITH outputCte AS
(
  SELECT
    KbBuchungID      = TMP.KbBuchungID,
    KontoNr          = TMP.KontoNr COLLATE DATABASE_DEFAULT,
    KontoName        = TMP.KontoName COLLATE DATABASE_DEFAULT,
    BetragSoll       = TMP.BetragSoll,
    BetragHaben      = TMP.BetragHaben,
    Betrag           = TMP.Betrag,
    BaPersonID$      = NULL,
    SollKontoNr      = TMP.SollKontoNr COLLATE DATABASE_DEFAULT,
    SollKonto        = TMP.SollKonto COLLATE DATABASE_DEFAULT,
    HabenKontoNr     = TMP.HabenKontoNr COLLATE DATABASE_DEFAULT,
    HabenKonto       = TMP.HabenKonto COLLATE DATABASE_DEFAULT,
    BelegNr          = TMP.BelegNr,
    KoaBelegNr       = BUC.BelegNr,
    Datum            = TMP.Datum,
    ValutaDatum      = TMP.ValutaDatum,
    Buchungtext      = TMP.Buchungtext COLLATE DATABASE_DEFAULT,
    Mitarbeiter      = TMP.Mitarbeiter COLLATE DATABASE_DEFAULT,
    Gegenkonto       = TMP.Gegenkonto COLLATE DATABASE_DEFAULT,
    Kostenart        = TMP.Kostenart,
    Kostenstelle     = STUFF((SELECT CONVERT(VARCHAR(MAX), SUB1.Text) -- Kostenstellen der Buchung zusammen setzen
                              FROM (SELECT DISTINCT
                                      [Text] = ',' + CASE BUC1.KbBuchungTypCode
                                                       WHEN 4 THEN -- Ausgleichsbuchung
                                                         STUFF((SELECT CONVERT(VARCHAR(MAX), SUB2.Text) -- Kostenstellen den Ausgleichsbuchungen zusammen setzen
                                                                FROM (SELECT DISTINCT
                                                                        [Text] = ',' + dbo.fnKbGetKostenstelle(KSTA.BaPersonID)
                                                                      FROM dbo.KbOpAusgleich                   OPA2 WITH (READUNCOMMITTED)
                                                                        INNER JOIN dbo.KbBuchungKostenart      KOAA WITH (READUNCOMMITTED) ON KOAA.KbBuchungID = OPA2.OpBuchungID
                                                                        INNER JOIN dbo.KbKostenstelle_BaPerson KSTA WITH (READUNCOMMITTED) ON KSTA.KbKostenstelleID = KOAA.KbKostenstelleID
                                                                      WHERE OPA2.AusgleichBuchungID = BUC1.KbBuchungID) AS SUB2
                                                                FOR XML PATH('')), 1, 1, '')
                                                       ELSE dbo.fnKbGetKostenstelle(KST1.BaPersonID)
                                                     END
                                    FROM #Temp TMP1
                                      INNER JOIN dbo.KbBuchung               BUC1 WITH (READUNCOMMITTED) ON BUC1.KbBuchungID = TMP1.KbBuchungID
                                      LEFT  JOIN dbo.KbBuchungKostenart      BKO1 WITH (READUNCOMMITTED) ON BKO1.KbBuchungID = BUC1.KbBuchungID
                                      LEFT  JOIN dbo.KbKostenstelle_BaPerson KST1 WITH (READUNCOMMITTED) ON KST1.KbKostenstelleID = BKO1.KbKostenstelleID
                                    WHERE TMP1.KbBuchungID = TMP.KbBuchungID) AS SUB1
                              FOR XML PATH('')), 1, 1, '') COLLATE DATABASE_DEFAULT,
    Vorsaldo         = TMP.Vorsaldo,
    Saldo            = 0.0,
    KbZahlungslaufID = TRF.KbZahlungslaufID,
    Verbucht         = TMP.Verbucht,
    Ausgeglichen     = TMP.Ausgeglichen,
    KbZahlungseingangID = TMP.KbZahlungseingangID
  FROM #Temp                    TMP
    LEFT JOIN dbo.KbOpAusgleich OPA WITH (READUNCOMMITTED) ON OPA.AusgleichBuchungID = TMP.KbBuchungID
    LEFT JOIN dbo.KbBuchung     BUC WITH (READUNCOMMITTED) ON BUC.KbBuchungID = OPA.OpBuchungID
    LEFT JOIN dbo.KbTransfer    TRF WITH (READUNCOMMITTED) ON (TRF.KbBuchungID = TMP.KbBuchungID OR TRF.KbBuchungID = BUC.KbBuchungID)
                                                          AND (TRF.KbTransferStatusCode IS NULL OR TRF.KbTransferStatusCode = 3) -- Nur Buchungen mit Zahlungslauf-Status "Bezahlt"
  WHERE (@auchUnverbuchte = 1 OR TMP.Verbucht = 1)
--- AND TRF.KbZahlungslaufID = {edtKbZahlungslaufIDX}

  UNION ALL
  
  SELECT
    KbBuchungID      = NULL,
    KontoNr          = KTO.KontoNr,
    KontoName        = KTO.KontoNr + ' ' + KTO.KontoName,
    BetragSoll       = ZEG.Betrag,
    BetragHaben      = 0.0,
    Betrag           = ZEG.Betrag,
    BaPersonID$      = ZEG.BaPersonID,
    SollKontoNr      = KTO.KontoNr,
    SollKonto        = KTO.KontoName,
    HabenKontoNr     = NULL,
    HabenKonto       = NULL,
    BelegNr          = NULL,
    KoaBelegNr       = NULL,
    Datum            = ZEG.Datum,
    ValutaDatum      = NULL,
    Buchungtext      = 'Debitor: ' + ZEG.Debitor,
    Mitarbeiter      = NULL,
    Gegenkonto       = NULL,
    Kostenart        = NULL,
    Kostenstelle     = dbo.fnKbGetKostenstelle(ZEG.BaPersonID),
    Vorsaldo         = VOR.Vorsaldo,
    Saldo            = 0.0,
    KbZahlungslaufID = NULL,
    Verbucht         = ZEG.Ausgeglichen,
    Ausgeglichen     = CASE 
                         WHEN ZEG.Ausgeglichen = 1
                           OR ZEG.Betrag = (SELECT SUM(BUC.Betrag)
                                            FROM dbo.KbBuchung BUC WITH (READUNCOMMITTED)
                                            WHERE BUC.KbZahlungseingangID = ZEG.KbZahlungseingangID)
                         THEN 1
                         ELSE 0
                       END,
    KbZahlungseingangID = ZEG.KbZahlungseingangID
  FROM dbo.KbKonto                    KTO WITH(READUNCOMMITTED)
    INNER JOIN @vorsaldo              VOR                       ON VOR.KbKontoID = KTO.KbKontoID
    INNER JOIN dbo.KbPeriode          PRD WITH(READUNCOMMITTED) ON PRD.KbPeriodeID = KTO.KbPeriodeID
    INNER JOIN dbo.KbZahlungseingang  ZEG WITH(READUNCOMMITTED) ON ZEG.KontoNr = KTO.KontoNr
                                                               AND dbo.fnDateOf(ZEG.Datum) &gt;= PRD.PeriodeVon
                                                               AND dbo.fnDateOf(ZEG.Datum) &lt;= PRD.PeriodeBis
---                                                            AND dbo.fnDateOf(ZEG.Datum) &gt;= {edtDatumVonX}
---                                                            AND dbo.fnDateOf(ZEG.Datum) &lt;= {edtDatumBisX}
---                                                            AND dbo.fnDateOf(ZEG.Datum) = {edtBezahltAmX}
                                                               AND NOT EXISTS(SELECT TOP 1 1
                                                                              FROM #Temp TMP
                                                                              WHERE TMP.KbZahlungseingangID = ZEG.KbZahlungseingangID)
                                                               AND ZEG.Ausgeglichen = 0
  WHERE @auchUnverbuchte = 1
    AND KTO.KbPeriodeID = @KbPeriodeID
    AND KTO.KbKontoklasseCode IN (5,6)
--- AND KTO.KbKontoID = {edtKontoX.LookupID}

  UNION ALL
  -- Vorsaldi einfügen
  SELECT
    KbBuchungID      = NULL,
    KontoNr          = TMP.KontoNr,
    KontoName        = TMP.KontoNr + ' ' + TMP.KontoName,
    BetragSoll       = 0.0,
    BetragHaben      = 0.0,
    Betrag           = VOR.Vorsaldo,
    BaPersonID$      = NULL,
    SollKontoNr      = NULL,
    SollKonto        = NULL,
    HabenKontoNr     = NULL,
    HabenKonto       = NULL,
    BelegNr          = NULL,
    KoaBelegNr       = NULL,
    Datum            = @VorsaldoDatum,
    ValutaDatum      = NULL,
    Buchungtext      = 'Vorsaldo',
    Mitarbeiter      = NULL,
    Gegenkonto       = NULL,
    Kostenart        = NULL,
    Kostenstelle     = NULL,
    Vorsaldo         = VOR.Vorsaldo,
    Saldo            = 0.0,
    KbZahlungslaufID = NULL,
    Verbucht         = NULL,
    Ausgeglichen     = NULL,
    KbZahlungseingangID = NULL
  FROM @vorsaldo VOR
  INNER JOIN KbKonto TMP ON TMP.KbKontoID = VOR.KbKontoID

)

SELECT 
  KontoNr          = KontoNr,
  KontoName        = KontoName,
  BetragSoll       = BetragSoll,
  BetragHaben      = BetragHaben,
  Betrag           = Betrag,
  BaPersonID$      = NULL,
  SollKontoNr      = SollKontoNr,
  SollKonto        = SollKonto,
  HabenKontoNr     = HabenKontoNr,
  HabenKonto       = HabenKonto,
  BelegNr          = BelegNr,
  KoaBelegNr       = dbo.ConcDistinct(KoaBelegNr),
  Datum            = Datum,
  ValutaDatum      = ValutaDatum,
  Buchungtext      = Buchungtext,
  Mitarbeiter      = Mitarbeiter,
  Gegenkonto       = Gegenkonto,
  Kostenart        = Kostenart,
  Kostenstelle     = Kostenstelle,
  Vorsaldo         = Vorsaldo,
  Saldo            = 0.0,
  KbZahlungslaufID = dbo.ConcDistinct(KbZahlungslaufID),
  [Status]         = CASE 
                       WHEN Verbucht = 1 THEN 'verbucht'
                       WHEN Ausgeglichen = 1 THEN 'ausgeglichen'
                       ELSE 'unausgeglichen'
                     END,
  KbZahlungseingangID = KbZahlungseingangID
FROM outputCte TMP
GROUP BY TMP.KbBuchungID, TMP.KontoNr, TMP.KontoName, TMP.BelegNr, TMP.Datum, TMP.ValutaDatum, TMP.Buchungtext, TMP.Mitarbeiter, TMP.Vorsaldo, TMP.Verbucht, TMP.Ausgeglichen, TMP.BetragSoll,
         TMP.BetragHaben, TMP.Betrag, TMP.SollKontoNr, TMP.SollKonto, TMP.HabenKontoNr, TMP.HabenKonto, TMP.Gegenkonto, TMP.Kostenart, TMP.Kostenstelle, TMP.KbZahlungseingangID

ORDER BY TMP.KontoNr, TMP.Datum ASC;
</value>
  </data>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="edtBezahltAmX.Properties.Buttons" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAAAwAAAAQCAYAAAAiYZ4HAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8
        YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABRSURBVDhPY2AAAmNj4//EYJBaMAApRqbhErjkiDEdZiiK
        Dcgmo7NxamhoYAA7DwSQ2Vg1gBTAFKHT1NGA7AyibBhuGoiKB5Jimpj0hM9AnHIA7aiPJlUTWpwAAAAA
        SUVORK5CYII=
</value>
  </data>
  <data name="edtDatumBisX.Properties.Buttons" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAAAwAAAAQCAYAAAAiYZ4HAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8
        YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABRSURBVDhPY2AAAmNj4//EYJBaMAApRqbhErjkiDEdZiiK
        Dcgmo7NxamhoYAA7DwSQ2Vg1gBTAFKHT1NGA7AyibBhuGoiKB5Jimpj0hM9AnHIA7aiPJlUTWpwAAAAA
        SUVORK5CYII=
</value>
  </data>
  <data name="edtDatumVonX.Properties.Buttons" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAAAwAAAAQCAYAAAAiYZ4HAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8
        YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABRSURBVDhPY2AAAmNj4//EYJBaMAApRqbhErjkiDEdZiiK
        Dcgmo7NxamhoYAA7DwSQ2Vg1gBTAFKHT1NGA7AyibBhuGoiKB5Jimpj0hM9AnHIA7aiPJlUTWpwAAAAA
        SUVORK5CYII=
</value>
  </data>
</root>