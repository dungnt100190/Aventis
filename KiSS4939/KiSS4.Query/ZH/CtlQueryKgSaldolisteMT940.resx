<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="qryQuery.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 19</value>
  </metadata>
  <data name="qryQuery.SelectStatement" xml:space="preserve">
    <value>DECLARE @OrgGruppeID INT;
SET @OrgGruppeID = NULL;
--- SET @OrgGruppeID = {ctlOrgUnitTeamUser.SucheGruppe};

DECLARE @TeamID INT;
SET @TeamID = NULL;
--- SET @TeamID = {ctlOrgUnitTeamUser.SucheTeam};

DECLARE @DatumBis DATETIME;
DECLARE @DatumBisMT940 DATETIME;

SET @DatumBis = GETDATE();
--- SET @DatumBis = {edtSucheDatumBis};
SET @DatumBisMT940 = @DatumBis;
SET @DatumBis = DATEADD(d, 1, @DatumBis); -- Einen Tag dazuaddieren und dann mit kleiner als Vergleichen


SELECT  NameVorname,
        BaPersonID,
        KontoNr,
        KontoName,
        BankKontoNummer,
        Stichtag,
        SaldoKiSS,
        SaldoMT940,
        AktualisierungsDatum,
        [Beist. oder Vorm.],
        OE,
        FallBaPersonID,
        AbweichungCHF     = SaldoKiSS - SaldoMT940,
        AbweichungProzent = CASE
                              WHEN ISNULL(SaldoMT940,0) &lt;&gt; 0
                                THEN CONVERT(MONEY,(SaldoKiSS - SaldoMT940) / [SaldoMT940] * 100,0)
                            END,
        KgPeriodeID,
        AktiveKLeistung
FROM (
  SELECT DISTINCT 
    PRS.NameVorname,
    LEI.BaPersonID, 
    KTO.KontoNr,
    KTO.KontoName,
    ZAH.BankKontoNummer,
    Stichtag             = DATEADD(d, -1, @DatumBis), -- Den Tag welcher dazugezählt wurde wieder abziehen
    SaldoKiSS            = ISNULL(KTO.Vorsaldo,0) -- Vorsaldo
                           + -- plus Sollbuchungen
                           (SELECT ISNULL(SUM(Betrag),0)
                            FROM dbo.KgBuchung WITH (READUNCOMMITTED)
                            WHERE KgPeriodeID = KTO.KgPeriodeID
                              AND SollKtoNr = KTO.KontoNr
                              AND Valutadatum &lt; @DatumBis)
                           - -- minus Habenbuchungen
                           (SELECT ISNULL(SUM(Betrag),0)
                            FROM dbo.KgBuchung WITH (READUNCOMMITTED)
                            WHERE KgPeriodeID = KTO.KgPeriodeID
                              AND HabenKtoNr = KTO.KontoNr
                              AND Valutadatum &lt; @DatumBis),
    -- Wir nehmen den ersten Eintrag, welcher zeitlich auf den gewählten Zeitpunkt folgt.
    -- Gibt es keinen Eintrag, nehmen wir den Eintrag unmittelbar vor dem gewählten Zeitpunkt.
    SaldoMT940           = SMT.Saldo,
    AktualisierungsDatum = SMT.Stichtag,
    [Beist. oder Vorm.]  = USR.NameVorname,
    OE                   = USR.OrgUnit,
    FallBaPersonID       = FAL.BaPersonID,
    KgPeriodeID          = PER.KgPeriodeID,
    AktiveKLeistung      = CAST(CASE
                                  WHEN LEI.DatumBis IS NULL OR LEI.DatumBis &gt;= @DatumBis THEN 1
                                  ELSE 0
                                END AS BIT)
  FROM dbo.FaLeistung             LEI WITH (READUNCOMMITTED)
    INNER JOIN dbo.FaFall         FAL WITH (READUNCOMMITTED) ON FAL.FaFallID = LEI.FaFallID
    INNER JOIN dbo.KgPeriode      PER WITH (READUNCOMMITTED) ON PER.KgPeriodeID = (SELECT TOP 1 PER2.KgPeriodeID
                                                                                   FROM dbo.KgPeriode PER2 WITH (READUNCOMMITTED)
                                                                                   WHERE PER2.FaLeistungID = LEI.FaLeistungID
                                                                                     AND PER2.PeriodeVon &lt;= GETDATE() -- Periode darf nicht in der Zukunft liegen
                                                                                     AND PER2.PeriodeVon &lt; @DatumBis -- Periode muss vor dem Stichtag (1 Tag wurde dazugezählt) gültig gewesen sein
                                                                                   ORDER BY PER2.PeriodeVon DESC) -- Neueste Periode holen, welche noch nicht in der Zukunft liegt zur jeweiligen Leistung
    LEFT  JOIN dbo.BaZahlungsweg  ZAH WITH (READUNCOMMITTED) ON ZAH.BaZahlungswegID = PER.BaZahlungswegID
    INNER JOIN dbo.KgKonto        KTO WITH (READUNCOMMITTED) ON KTO.KgPeriodeID = PER.KgPeriodeID AND KTO.KgKontoartCode = 1 /*Kontokorrentkonto*/
    INNER JOIN dbo.vwPersonSimple PRS WITH (READUNCOMMITTED) ON PRS.BaPersonID = LEI.BaPersonID
    INNER JOIN dbo.vwUser         USR WITH (READUNCOMMITTED) ON USR.UserID = LEI.UserID
    OUTER APPLY (SELECT TOP 1 Saldo = SMT1.Saldo + ISNULL(BUC.Betrag, 0), Stichtag = SMT1.Stichtag
                 FROM dbo.SstMT940Saldo SMT1 WITH (READUNCOMMITTED)
                   OUTER APPLY (SELECT Betrag = SUM(KGZ.Betrag)
                                FROM dbo.KgZahlungseingang KGZ WITH (READUNCOMMITTED)
                                WHERE KGZ.PscdKontoKlient = SMT1.Kontonummer
                                  AND KGZ.PscdKontoauszug &gt;= SMT1.PscdKontoauszugID --wir benötigen die Buchungen des Kontoauszugs (End-Saldo) und aller folgenden Kontoauszüge
                                  AND (KGZ.Datum &lt;= @DatumBisMT940 OR @DatumBisMT940 IS NULL)) BUC  --solange das ValutaDatum der Buchungen des Kontoauszugs &lt;= dem Stichtag ist
                 WHERE SMT1.BaPersonID = LEI.BaPersonID
                   AND (SMT1.Stichtag &lt;= @DatumBisMT940 OR @DatumBisMT940 IS NULL)
                 ORDER BY SMT1.Stichtag DESC, SMT1.Created DESC) SMT
  WHERE ((@OrgGruppeID IS NULL AND @TeamID IS NULL) OR USR.OrgUnitID IN (SELECT OrgUnitID FROM dbo.fnOrgUnitsOfTeam(@OrgGruppeID,@TeamID)))
  ---AND LEI.UserID = {ctlOrgUnitTeamUser.SucheUserID.LookupID}
  ---AND ({edtNurAktiveVerkehrskonti.EditValue} = 0 OR (ZAH.BaZahlungswegID IS NOT NULL AND (ZAH.DatumBis IS NULL OR ZAH.DatumBis &gt;= @DatumBis) AND ZAH.BaKontoartCode = 4))
    AND KTO.KgKontoklasseCode IN (1, 2, 3, 4)
) T
ORDER BY T.NameVorname;</value>
  </data>
  <metadata name="qryAbgleichBuc.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>119, 17</value>
  </metadata>
  <data name="qryAbgleichBuc.SelectStatement" xml:space="preserve">
    <value>-- Weist den MT940-Einträgen Buchungen zu und umgekehrt, um Differenzen schnell aufzufinden
DECLARE /*@KgPeriodeID int, */@BaPersonID int, @DatumVon datetime, @DatumBis datetime,
  @MaxDatumDiff int, @MaxDatumNegDiff int, @StichDatum datetime, @MaxRecursion int,
  @MaxDatumLoopCount int

-- Maximale Datumsdifferenz
SET @MaxDatumDiff = 0
SET @MaxDatumNegDiff = -7 -- 1 Woche
---- Fallback, falls bei vorigem nichts gefunden wird
SET @MaxDatumLoopCount = 5

-- hoechster gesehener Wert: 9 bei KgPeriodeID 9412, BaPersonID 137886
SET @MaxRecursion = 15

SET @BaPersonID = {0}
SET @StichDatum = {1}

-- funktioniert mehrheitlich (verwendet Methoden 1,2,3,4,5,6,7,9,88,100):
--SET @BaPersonID = 137886
-- funktioniert:
--SET @BaPersonID = 189543
--SET @BaPersonID = 205892
--SET @BaPersonID = 140572 -- (Verwendet Methoden 1,2,3,4,10)
--SET @BaPersonID = 215668
--SET @BaPersonID = 188940
--SET @BaPersonID = 158049

SELECT @DatumVon = MIN(PeriodeVon), @DatumBis = CONVERT(DateTime, dbo.fnMIN(MAX(PeriodeBis), ISNULL(@StichDatum, MAX(PeriodeBis))))
FROM FaLeistung LEI
  INNER JOIN KgPeriode PER ON PER.FaLeistungID = LEI.FaLeistungID AND PER.KgPeriodeStatusCode &lt;&gt; 3 /*abgeschlossene Perioden müssten stimmen*/
WHERE LEI.BapersonID = @BaPersonID AND LEI.FaProzessCode = 500
  AND (PER.PeriodeBis &gt;= @Stichdatum AND PER.PeriodeVon &lt;= @Stichdatum OR @Stichdatum IS NULL) 

--SELECT @DatumVon, @DatumBis, @BaPersonID

-- Alte Temporäre Tabellen aufräumen
IF OBJECT_ID('tempdb..#ZAH') IS NOT NULL BEGIN
  DROP TABLE #ZAH
END
IF OBJECT_ID('tempdb..#BUC') IS NOT NULL BEGIN
  DROP TABLE #BUC
END
-- Alten Cursor aufräumen
IF Cursor_Status('global', 'cZahl') &gt; 0 BEGIN
  CLOSE cZahl
  DEALLOCATE cZahl
END

-- Ist das Feld "bearbeitet" &lt;&gt; 0, so wurde der Zahlungseingang zur Buchung bzw. die Buchung zum Zahlungseingang
-- gefunden. Die Nummer im Feld "bearbeitet" weist darauf hin, durch welche Methode der Verknüfung gefunden wurde.
SELECT KgZahlungseingangID, Betrag, Datum, Bearbeitet = 0, GVC_Code = ISNULL(COD.Text + ' ', '') + '(' + CONVERT(VARCHAR(5), ZAH.KgZahlungseingangArtCode) + ')', Mitteilung = Replace(Mitteilung, char(10), '')
INTO #ZAH
FROM dbo.KgZahlungseingang ZAH
  LEFT JOIN dbo.XLOVCode COD ON COD.LOVName = 'KgZahlungseingangArt' AND COD.Code = ZAH.KgZahlungseingangArtCode
WHERE BaPersonID = @BaPersonID
  AND ZAH.Datum BETWEEN @DatumVon AND @DatumBis
  AND ZAH.PscdKontoKlient IS NOT NULL /*Nur automatisch erstellte Einträge, keine Benutzer-Erstellte Einträge*/
ORDER BY Datum


SELECT BUC.KgBuchungID, BUC.Betrag, BUC.Buchungsdatum, Bearbeitet = 0, KgBuchungStatusCode, KgZahlungseingangID, StorniertKgBuchungID, ValutaDatum,
  Konto = BUC.HabenKtoNr, Buchungstext = Text, DatumEffektiv = BUC.Buchungsdatum, Barbeleg = 0
INTO #BUC
FROM KgBuchung BUC WHERE 1 = 0

SET IDENTITY_INSERT #BUC ON
-- Einzahlungen
INSERT INTO #BUC (KgBuchungID, Betrag, Buchungsdatum, Bearbeitet, KgBuchungStatusCode, KgZahlungseingangID, StorniertKgBuchungID, ValutaDatum,
  Konto, Buchungstext, DatumEffektiv, Barbeleg)
SELECT BUC.KgBuchungID, BUC.Betrag, BUC.Buchungsdatum, Bearbeitet = 0, KgBuchungStatusCode, KgZahlungseingangID, StorniertKgBuchungID, ValutaDatum,
  Konto = BUC.HabenKtoNr, Buchungstext = Text, DatumEffektiv = BUC.Buchungsdatum, Barbeleg = 0
FROM dbo.FaLeistung LEI
  INNER JOIN dbo.KgPeriode PER ON PER.FaLeistungID = LEI.FaLeistungID
  INNER JOIN dbo.KgBuchung BUC ON BUC.KgPeriodeID = PER.KgPeriodeID AND BUC.BuchungsDatum &gt;= @DatumVon AND BUC.BuchungsDatum &lt;= @DatumBis
  INNER JOIN dbo.KgKonto KON ON KON.KgPeriodeID = BUC.KgPeriodeID AND KON.KontoNr = BUC.SollKtoNr AND KON.KgKontoArtCode = 1 /*Kontokorrentkonto*/
WHERE LEI.BaPersonID = @BaPersonID AND PER.PeriodeBis &gt;= @DatumVon AND PER.PeriodeVon &lt;= @DatumBis

-- Auszahlungen
INSERT INTO #BUC (KgBuchungID, Betrag, Buchungsdatum, Bearbeitet, KgBuchungStatusCode, KgZahlungseingangID, StorniertKgBuchungID, ValutaDatum,
  Konto, Buchungstext, DatumEffektiv, Barbeleg)
SELECT BUC.KgBuchungID, -BUC.Betrag, BUC.Buchungsdatum, Bearbeitet = 0, KgBuchungStatusCode, KgZahlungseingangID, StorniertKgBuchungID, ValutaDatum,
  Konto = BUC.SollKtoNr, Buchungstext = Text, DatumEffektiv = BUC.Buchungsdatum, Barbeleg = 0
FROM dbo.FaLeistung LEI
  INNER JOIN dbo.KgPeriode PER ON PER.FaLeistungID = LEI.FaLeistungID
  INNER JOIN dbo.KgBuchung BUC ON BUC.KgPeriodeID = PER.KgPeriodeID AND BUC.BuchungsDatum &gt;= @DatumVon AND BUC.BuchungsDatum &lt;= @DatumBis
  INNER JOIN dbo.KgKonto KON ON KON.KgPeriodeID = BUC.KgPeriodeID AND KON.KontoNr = BUC.HabenKtoNr AND KON.KgKontoArtCode = 1 /*Kontokorrentkonto*/
WHERE LEI.BaPersonID = @BaPersonID AND PER.PeriodeBis &gt;= @DatumVon AND PER.PeriodeVon &lt;= @DatumBis
SET IDENTITY_INSERT #BUC OFF

-- Für Barbelege stimmt das Effektiv-Datum nicht (Stand Februar 2011). PSCD liefert das Datum, an dem der Beleg von der
-- Stadtkasse ausbezahlt wurde. Interessant wäre aber das Datum, an dem der Betrag bei der ZKB belastet wird.
-- Dieses zweite Datum müsste in etwa dann sein, wenn wir die Ausgleichsmeldung von PSCD erhalten.
-- Einige Belege werden von Hand nachkorrigiert.
UPDATE #BUC
SET DatumEffektiv = ISNULL(PSC.ErstelltDatum, DatumEffektiv), Barbeleg = 1
FROM #BUC BUC
INNER JOIN
(
  SELECT BUC.KgBuchungID, ErstelltDatum = MIN(PSC.ErstelltDatum)
  FROM #BUC BUC
    INNER JOIN kgopausgleich aug on aug.ausgleichbuchungid = buc.kgbuchungid
    INNER JOIN kgbuchung buc2 on buc2.kgbuchungid = aug.opbuchungid
    LEFT JOIN pscdausgleich PSC on PSC.opbel = buc2.pscdbelegnr
  WHERE buc2.KgAuszahlungsArtcode = 103 /* Barauszahlung */ AND BUC.Betrag &lt; 0 
  GROUP BY BUC.KgBuchungID
) PSC ON PSC.KgBuchungID = BUC.KgBuchungID

-- Leider bringt der Index nicht wirklich eine Performance-Verbesserung
CREATE INDEX IX_TEMP_BUC_Zahl ON #BUC (Bearbeitet ASC, Buchungsdatum)
INCLUDE(KgZahlungseingangID, KgBuchungStatusCode, StorniertKgBuchungID, Valutadatum, Betrag, DatumEffektiv)

-- Stornos entfernen
UPDATE BUC
SET Bearbeitet = 88
FROM #BUC BUC
  INNER JOIN #BUC BUC2 ON BUC.StorniertKgBuchungID = BUC2.KgBuchungID AND BUC2.KgBuchungStatusCode = 8 /*storniert*/
WHERE BUC.KgBuchungStatusCode = 8 /*storniert*/
-- Storno-Gegenbuchung entfernen
UPDATE BUC
SET Bearbeitet = 88
FROM #BUC BUC
  INNER JOIN #BUC BUC2 ON BUC2.StorniertKgBuchungID = BUC.KgBuchungID AND BUC2.KgBuchungStatusCode = 8 /*storniert*/
WHERE BUC.KgBuchungStatusCode = 8 /*storniert*/

-- Vollständig geklärte Buchungen und deren Zahlungseingänge entfernen
UPDATE #BUC
SET Bearbeitet = 100
WHERE KgZahlungseingangID IN
(
  SELECT ZAH.KgZahlungseingangID
  FROM #ZAH ZAH
    INNER JOIN #BUC BUC ON BUC.KgZahlungseingangID = ZAH.KgZahlungseingangID
  GROUP BY ZAH.KgZahlungseingangID
  HAVING SUM(BUC.Betrag) = SUM(ZAH.Betrag)
)
UPDATE #ZAH
SET Bearbeitet = 100
WHERE KgZahlungseingangID IN
(
  SELECT ZAH.KgZahlungseingangID
  FROM #ZAH ZAH
    INNER JOIN #BUC BUC ON BUC.KgZahlungseingangID = ZAH.KgZahlungseingangID
  GROUP BY ZAH.KgZahlungseingangID
  HAVING SUM(BUC.Betrag) = SUM(ZAH.Betrag)
)

DECLARE @KgZahlungseingangID int, @Betrag money, @Datum datetime, @DatumLoopCount int
DECLARE cZahl CURSOR FAST_FORWARD FOR
    SELECT KgZahlungseingangID, Betrag, Datum 
    FROM #zah               zah
    WHERE zah.bearbeitet = 0
DECLARE @KgBuchungID1 int, @KgBuchungID2 int, @KgBuchungID3 int, @KgBuchungID4 int, @KgBuchungID5 int

-- Zwei Versuche: Beim zweiten Versuch das Datum nicht so genau nehmen
SET @DatumLoopCount = 0

OPEN cZahl

WHILE @DatumLoopCount &lt; @MaxDatumLoopCount AND (EXISTS (SELECT TOP 1 1 FROM #ZAH WHERE Bearbeitet = 0)) BEGIN
  FETCH NEXT FROM cZahl INTO @KgZahlungseingangID, @Betrag, @Datum
  IF @@FETCH_STATUS &lt; 0 BEGIN
--    SELECT 'Loop updated', @DatumLoopCount, @MaxDatumDiff, @MaxDatumNegDiff, (SELECT COUNT(1) FROM #ZAH WHERE Bearbeitet = 0)
    SET @DatumLoopCount = @DatumLoopCount + 1
    SET @MaxDatumDiff = @MaxDatumDiff + 7
    SET @MaxDatumNegDiff = @MaxDatumNegDiff - 7
    CLOSE cZahl
    OPEN cZahl
    CONTINUE
  END

DECLARE @KgBuchungen VARCHAR(200), @Rekursionstiefe int
SELECT @KgBuchungen = NULL, @Rekursionstiefe = -1
;WITH Buchung
(
  KgBuchungen, -- alle K-Buchungen
  RestBetrag,
  Recursion,
  LastKgBuchungID,
  DatumDiffSum -- Summe der Datumsdifferenzen
)
AS
(
  SELECT KgBuchungen = Convert(varchar(100), BUC.KgBuchungID), RestBetrag = @Betrag - BUC.Betrag, Recursion = 1, LastKgBuchungID = BUC.KgBuchungID,
    DatumDiffSum = abs(DateDiff(day, BUC.DatumEffektiv, @Datum))
  FROM #BUC BUC
  WHERE Bearbeitet = 0
    AND BUC.DatumEffektiv BETWEEN DateAdd(D, @MaxDatumNegDiff, @Datum) AND DateAdd(D, @MaxDatumDiff, @Datum)
    AND (BUC.KgBuchungStatusCode IS NULL OR BUC.KgBuchungStatusCode &lt;&gt; 8)
  UNION ALL
  SELECT KgBuchungen = convert(varchar(100), KgBuchungen + ',' + Convert(varchar(200), BUC2.KgBuchungID)), RestBetrag = BUC.RestBetrag - BUC2.Betrag,
    Recursion = Recursion + 1, LastKgBuchungID = BUC2.KgBuchungID, DatumDiffSum = DatumDiffSum  + abs(DateDiff(day, BUC2.DatumEffektiv, @Datum))
  FROM Buchung BUC
    INNER JOIN #BUC BUC2 ON BUC2.Bearbeitet = 0 AND BUC2.KgBuchungID &gt; BUC.LastKgBuchungID
      AND (BUC2.KgBuchungStatusCode IS NULL OR BUC2.KgBuchungStatusCode &lt;&gt; 8)
  WHERE BUC2.DatumEffektiv BETWEEN DateAdd(D, @MaxDatumNegDiff, @Datum) AND DateAdd(D, @MaxDatumDiff, @Datum)
    AND Recursion &lt;= @MaxRecursion
)
SELECT TOP 1 @KgBuchungen = KgBuchungen, @Rekursionstiefe = Recursion
FROM Buchung
WHERE RestBetrag = 0
ORDER BY Recursion ASC /*Möglichst wenige Einträge (d.h. hohe Beträge)*/, DatumDiffSum DESC /*Annahme dass die ältesten am schnellsten bezahlt werden*/


IF @KgBuchungen IS NOT NULL
BEGIN
--  SELECT * FROM #BUC WHERE KgBuchungID IN (
--    SELECT SplitValue FROM dbo.fnSplitStringToValues(@KgBuchungen, ',', 1)
--  )
--  SELECT * FROM #ZAH WHERE KgZahlungseingangID = @KgZahlungseingangID
  UPDATE #BUC SET Bearbeitet = @Rekursionstiefe WHERE KgBuchungID IN (
    SELECT SplitValue FROM dbo.fnSplitStringToValues(@KgBuchungen, ',', 1)
  )
  UPDATE #ZAH SET Bearbeitet = @Rekursionstiefe WHERE KgZahlungseingangID = @KgZahlungseingangID
END

END

SELECT * FROM #BUC WHERE Bearbeitet = 0 ORDER BY Buchungsdatum
SELECT * FROM #ZAH WHERE Bearbeitet = 0 ORDER BY Datum

--SELECT * FROM #BUC WHERE Bearbeitet &gt; 0 AND (@StichDatum IS NULL OR Buchungsdatum &lt;= @StichDatum) ORDER BY Buchungsdatum
--SELECT * FROM #ZAH WHERE Bearbeitet &gt; 0 AND (@StichDatum IS NULL OR Datum &lt;= @StichDatum) ORDER BY Datum
--
--SELECT * FROM #BUC WHERE Bearbeitet &lt; 0 OR Bearbeitet is null
--SELECT * FROM #ZAH WHERE Bearbeitet &lt; 0 OR Bearbeitet is null
--
--SELECT BucBearbeitet = SUM(Betrag) FROM #BUC WHERE Bearbeitet &gt; 0
--SELECT ZahBearbeitet = SUM(Betrag) FROM #ZAH WHERE Bearbeitet &gt; 0
--
--SELECT BucUnbeareitet = SUM(Betrag) FROM #BUC WHERE Bearbeitet = 0
--SELECT ZahUnbeareitet = SUM(Betrag) FROM #ZAH WHERE Bearbeitet = 0
--
--SELECT Bearbeitet, Count(1) FROM #BUC GROUP BY Bearbeitet 

-- Vorsaldo vergleichen
--SELECT KON.Vorsaldo, (SELECT TOP 1 ESBTR FROM dbo.SstMT940Saldo SAL WHERE SAL.BaPersonID = @BaPersonID AND SAL.Stichtag &lt; PER.PeriodeVon ORDER BY SAL.Stichtag DESC)
--FROM FaLeistung LEI
--  INNER JOIN KgPeriode PER ON PER.FaLeistungID = LEI.FaLeistungID AND PER.KgPeriodeStatusCode &lt;&gt; 3 /*abgeschlossene Perioden müssten stimmen*/
--  INNER JOIN KgKonto KON ON KON.KgPeriodeID = PER.KgPeriodeID AND KON.KgKontoArtCode = 1 /*Kontokorrentkonto*/
--WHERE LEI.BapersonID = @BaPersonID AND LEI.FaProzessCode = 500
--  AND (PER.PeriodeBis &gt;= @Stichdatum AND PER.PeriodeVon &lt;= @Stichdatum OR @Stichdatum IS NULL) 

--SELECT (SELECT SUM(Betrag) FROM #ZAH) - (SELECT SUM(Betrag) FROM #BUC)
--SELECT Konto, SUM(Betrag) FROM #BUC where betrag &gt; 0 and buchungsdatum between ''2008-10-01 00:00:00.000'' and ''2010-09-30 00:00:00.000'' GROUP BY Konto
--SELECT Konto, SUM(Betrag) FROM #BUC where betrag &lt; 0 and buchungsdatum between ''2008-10-01 00:00:00.000'' and ''2010-09-30 00:00:00.000'' GROUP BY Konto
CLOSE cZahl
DEALLOCATE cZahl
    
DROP TABLE #ZAH
DROP TABLE #BUC</value>
  </data>
  <metadata name="qryAbgleichMT940.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>256, 17</value>
  </metadata>
  <data name="qryAbgleichMT940.SelectStatement" xml:space="preserve">
    <value>-- Alte Temporäre Tabellen aufräumen
IF OBJECT_ID('tempdb..#ZAH') IS NOT NULL BEGIN
  DROP TABLE #ZAH
END

SELECT KgZahlungseingangID, Betrag, Datum, Bearbeitet = 0, GVC_Code = ISNULL(COD.Text + ' ', '') + '(' + CONVERT(VARCHAR(5), ZAH.KgZahlungseingangArtCode) + ')', Mitteilung = Replace(Mitteilung, char(10), '')
INTO #ZAH
FROM KgZahlungseingang ZAH
  LEFT JOIN dbo.XLOVCode COD ON COD.LOVName = 'KgZahlungseingangArt' AND COD.Code = ZAH.KgZahlungseingangArtCode
WHERE 1 = 2

SELECT * FROM #ZAH 
    
DROP TABLE #ZAH


</value>
  </data>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="edtSucheDatumBis.Properties.Buttons" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAAAwAAAAQCAYAAAAiYZ4HAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8
        YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABRSURBVDhPY2AAAmNj4//EYJBaMAApRqbhErjkiDEdZiiK
        Dcgmo7NxamhoYAA7DwSQ2Vg1gBTAFKHT1NGA7AyibBhuGoiKB5Jimpj0hM9AnHIA7aiPJlUTWpwAAAAA
        SUVORK5CYII=
</value>
  </data>
</root>