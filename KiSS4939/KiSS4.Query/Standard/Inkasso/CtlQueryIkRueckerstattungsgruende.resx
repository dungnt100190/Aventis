<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="qryQuery.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <data name="qryQuery.SelectStatement" xml:space="preserve">
    <value>--Such-Parameter
DECLARE @UserID INT,
        @InkassoTypCode INT,
        @IkRueckerstattungTypCode INT,
        @IkAbklaerungArt INT,
        @InklAbgeschlossen BIT,
        @InklArchiviert BIT,
        @ZeitraumVon DATETIME,
        @ZeitraumBis DATETIME,
        @ZahlungDatumVon DATETIME,
        @ZahlungDatumBis DATETIME,
        @ForderungDatumVon DATETIME,
        @ForderungDatumBis DATETIME,
        @ForderungenInZeitraum BIT,
        @ZahlungenInZeitraum BIT,
        @UnterstuetzungsendeVon DATETIME,
        @UnterstuetzungsendeBis DATETIME;
        
---SET @UserID = {edtUserID.LookupID};
---SET @InkassoTypCode = {edtInkassoTyp};
---SET @IkRueckerstattungTypCode = {edtRueckerstattungTyp};
---SET @IkAbklaerungArt = {edtAbklaerungArt};
---SET @InklAbgeschlossen = {edtInklAbgeschlossen};
---SET @InklArchiviert = {edtInklArchiviert};
---SET @ZeitraumVon = {edtZeitraumVon};
---SET @ZeitraumBis = {edtZeitraumBis};
---SET @ForderungenInZeitraum = {edtForderungenInZeitraum.Checked};
---SET @ZahlungenInZeitraum = {edtZahlungenInZeitraum.Checked};
---SET @UnterstuetzungsendeVon = {edtUnterstuetzungsendeVon};
---SET @UnterstuetzungsendeBis = {edtUnterstuetzungsendeBis};


--Zeitraum anwenden auf Forderung und/oder Zahlung?
IF(@ForderungenInZeitraum = 1)
BEGIN
  SELECT @ForderungDatumVon = @ZeitraumVon,
         @ForderungDatumBis = @ZeitraumBis;
END  
ELSE
BEGIN
  SELECT @ForderungDatumVon = '19000101',
         @ForderungDatumBis = '29991231';
END
IF(@ZahlungenInZeitraum = 1)
BEGIN
  SELECT @ZahlungDatumVon = @ZeitraumVon,
         @ZahlungDatumBis = @ZeitraumBis;
END  
ELSE
BEGIN
  SELECT @ZahlungDatumVon = '19000101',
         @ZahlungDatumBis = '29991231';
END

--Variablen
DECLARE @TODAY_NOTIME DATETIME
SET @TODAY_NOTIME = dbo.fnDateOf(GETDATE());

DECLARE @tspGetKontoauszug TABLE (
  tspGetKontoauszugID int IDENTITY(1,1) NOT NULL,
  KbBuchungID     INT,
  Typ			        VARCHAR(50),
  BelegNr		      INT,
  Datum           DATETIME,
  DatumForderung  DATETIME,
  Glaeubiger      VARCHAR(100), 
  Schuldner       VARCHAR(100), 
  [Text]          VARCHAR(200),
  BetragSoll      MONEY,
  BetragHaben     MONEY,
  SollKto		      VARCHAR(10), 
  HabenKto		    VARCHAR(10),
  Saldo           MONEY,
  KbOpAusgleichID INT,
  BaPersonID	    INT,
  FaLeistungID    INT,
  Einmalig        BIT,
  Einnahmen       BIT,
  Bemerkung       VARCHAR(500)
  PRIMARY KEY(tspGetKontoauszugID)
);

DECLARE @Leistungen TABLE (
  ID INT NOT NULL IDENTITY(1, 1) PRIMARY KEY CLUSTERED,
  FaLeistungIDList VARCHAR(MAX)
);

DECLARE @FaLeistungIDList VARCHAR(MAX);
DECLARE @EntriesCount INT;
DECLARE @EntriesIterator INT;
-------------------------------------------------------------------------------
-- insert entries into @Leistungen table
-------------------------------------------------------------------------------
;WITH FaLeistungID_Distinct_CTE AS 
(
  SELECT DISTINCT LEI.FaLeistungID
  FROM dbo.FaLeistung LEI WITH (READUNCOMMITTED)
    OUTER APPLY (SELECT TOP 1 LAB.FaLeistungID, ABK.IkAbklaerungArtCode
                 FROM FaLeistung LAB
                   INNER JOIN dbo.IkAbklaerung ABK ON ABK.FaLeistungID = LAB.FaLeistungID
                 WHERE LAB.ModulID = 4
                   AND LAB.FaProzessCode = 400 --Abklärung
                   AND LAB.BaPersonID = LEI.BaPersonID
                   AND (@IkAbklaerungArt IS NULL OR ABK.IkAbklaerungArtCode = @IkAbklaerungArt) --es interessieren nur die Abklärungen der ausgewählten Art
                 ORDER BY ABK.DatumAbklaerung, ABK.IkAbklaerungID DESC
                 ) ABK

    INNER  JOIN dbo.IkPosition POS WITH (READUNCOMMITTED) ON POS.FaLeistungID = LEI.FaLeistungID
                                                        AND POS.Einmalig = 1 --nur einmalige Forderungen
                                                        AND (@ForderungDatumVon IS NULL OR POS.Datum &gt;= @ForderungDatumVon)
                                                        AND (@ForderungDatumBis IS NULL OR POS.Datum &lt;= @ForderungDatumBis)

    LEFT  JOIN dbo.FaLeistungArchiv ARC WITH (READUNCOMMITTED) ON ARC.FaLeistungID = LEI.FaLeistungID AND ARC.CheckOut is NULL

    LEFT  JOIN dbo.FaLeistung LES WITH (READUNCOMMITTED) ON LES.BaPersonID = LEI.BaPersonID 
                                                        AND LES.ModulID = 3
                                                        AND (@UnterstuetzungsendeVon IS NULL OR LES.DatumBis &gt;= @UnterstuetzungsendeVon)
                                                        AND (@UnterstuetzungsendeBis IS NULL OR LES.DatumBis &lt;= @UnterstuetzungsendeBis)

  WHERE LEI.FaProzessCode &lt;&gt; 400
    AND (@UserID IS NULL OR LEI.UserID = @UserID)
    AND (@InkassoTypCode IS NULL OR LEI.FaProzessCode = @InkassoTypCode)
    AND (@IkRueckerstattungTypCode IS NULL OR LEI.IkRueckerstattungTypCode = @IkRueckerstattungTypCode)
    AND (@IkAbklaerungArt IS NULL OR ABK.IkAbklaerungArtCode = @IkAbklaerungArt)
    AND (@InklAbgeschlossen = 1 OR (LEI.DatumBis IS NULL OR LEI.DatumBis &gt; @TODAY_NOTIME))
    AND (@InklArchiviert = 1 OR ARC.FaLeistungID is null)
    AND (@UnterstuetzungsendeVon IS NULL OR LES.DatumBis &gt;= @UnterstuetzungsendeVon)
    AND (@UnterstuetzungsendeBis IS NULL OR LES.DatumBis &lt;= @UnterstuetzungsendeBis)
),
FaLeistungID_CTE AS
(
  SELECT 
    Rank = RANK() OVER (ORDER BY FaLeistungID), 
    RankGroup = (RANK() OVER (ORDER BY FaLeistungID) - 1) / 1000, 
    FaLeistungID = CONVERT(VARCHAR(MAX), FaLeistungID)
  FROM FaLeistungID_Distinct_CTE
)

INSERT INTO @Leistungen (FaLeistungIDList)
  SELECT 
    --MIN(Rank), MAX(Rank), SUM(LEN(FaLeistungID) + 1)-1,
    FaLeistungIDs = STUFF((SELECT ',' + SUB.FaLeistungID
                           FROM FaLeistungID_CTE SUB
                           WHERE SUB.RankGroup = CTE.RankGroup
                           FOR XML PATH('')),
                           1,
                           1, 
                           '')
  FROM FaLeistungID_CTE CTE
  GROUP BY  RankGroup;

-- prepare vars for loop
SET @EntriesCount = @@ROWCOUNT;  -- needs to be done just after filling!
SET @EntriesIterator = 1;        -- needs to start just at the same value as IDENTITY column on table

-------------------------------------------------------------------------------
-- loop all entries
-------------------------------------------------------------------------------
WHILE (@EntriesIterator &lt;= @EntriesCount)
BEGIN
  -- get current entry
  SELECT @FaLeistungIDList = TMP.FaLeistungIDList
  FROM @Leistungen TMP
  WHERE TMP.ID = @EntriesIterator;
  
  --Forderung-/Zahlung-Daten ermitteln
  INSERT INTO @tspGetKontoauszug 
  EXEC spIkGetKontoauszug /*@Forderungsart*/null, /*@GlaeubigerBaPersonID*/null, /*@SchuldnerBaPersonID*/null, @FaLeistungIDList, @ZahlungDatumVon, @ZahlungDatumBis, @ForderungDatumVon, @ForderungDatumBis, /*@InklusiveEinmalige*/1, /*@MitSaldovortrag*/0, /*Verdichtet*/0, /*@ZahlungseingangEinmaligPeriodischUnterscheiden*/1
  
  -- prepare for next entry
  SET @EntriesIterator = @EntriesIterator + 1;
END;

--Resultat-Tabelle bereinigen:
--Wenn nach Zahlungen eingeschränkt wurde, jedoch nicht nach Forderungen,
--dann nur Forderungen anzeigen, welche auch Zahlungseingänge aufweisen
IF(@ForderungenInZeitraum =  0 AND @ZahlungenInZeitraum =  1)
BEGIN
  DELETE T 
  FROM @tspGetKontoauszug T
  WHERE T.KbOpAusgleichID = -1 
    AND NOT EXISTS (SELECT TOP 1 1 
                FROM @tspGetKontoauszug TI 
                  INNER JOIN KbOpAusgleich AUS ON AUS.KbOpAusgleichID = TI.KbOpAusgleichID
                WHERE T.KbBuchungID = AUS.OpBuchungID
                )
END

--Resultset #1: Register: Liste
SELECT 
  [SAR]                    = USR.LogonName,
  [Schuldner]              = PRS.NameVorname,
  [Rückerstattungs-Typ]    = dbo.fnLOVText('IkRueckerstattungTyp', LEI.IkRueckerstattungTypCode),
  [Abklärungsart]          = dbo.fnLOVText('IkAbklaerungArt', CONVERT(INT, ABK.IkAbklaerungArtCode)),
  [Total Soll in Fr.]      = SUM(BetragSoll),
  [Total Haben in Fr.]     = SUM(BetragHaben),
  [Saldo in Fr.]           = SUM(BetragSoll)-SUM(BetragHaben),
  [BaPersonID$]            = PRS.BaPersonID,
  [FaLeistungID$]          = LEI.FaLeistungID
FROM @tspGetKontoauszug T
  INNER JOIN FaLeistung LEI ON LEI.FaLeistungID = T.FaLeistungID
  INNER JOIN vwPerson PRS ON PRS.BaPersonID = LEI.BaPersonID
  INNER JOIN XUser USR ON USR.UserID = LEI.UserID
  
  OUTER APPLY (SELECT TOP 1 LAB.FaLeistungID, ABK.IkAbklaerungArtCode
               FROM FaLeistung LAB
                 INNER JOIN dbo.IkAbklaerung ABK ON ABK.FaLeistungID = LAB.FaLeistungID
               WHERE LAB.ModulID = 4
                 AND LAB.FaProzessCode = 400 --Abklärung
                 AND LAB.BaPersonID = LEI.BaPersonID
                 AND (@IkAbklaerungArt IS NULL OR ABK.IkAbklaerungArtCode = @IkAbklaerungArt) --es interessieren nur die Abklärungen der ausgewählten Art
               ORDER BY ABK.DatumAbklaerung, ABK.IkAbklaerungID DESC
               ) ABK

WHERE T.Einmalig = 1
GROUP BY USR.LogonName, PRS.NameVorname, PRS.BaPersonID, LEI.FaLeistungID, LEI.IkRueckerstattungTypCode, ABK.IkAbklaerungArtCode;

--Resultset #2: Register: Zusammenzug
SELECT 
  [SAR]                    = USR.LogonName,
  [Rückerstattungs-Typ]    = dbo.fnLOVText('IkRueckerstattungTyp', LEI.IkRueckerstattungTypCode),
  [Abklärungsart]          = dbo.fnLOVText('IkAbklaerungArt', CONVERT(INT, ABK.IkAbklaerungArtCode)),
  [Anzahl Sollstellungen]  = SUM(CASE T.Einnahmen WHEN 0 THEN 1 ELSE 0 END),
  [Anzahl Zahlungen]       = SUM(CASE T.Einnahmen WHEN 1 THEN 1 ELSE 0 END),
  [Total Soll in Fr.]      = SUM(BetragSoll),
  [Total Haben in Fr.]     = SUM(BetragHaben),
  [Saldo in Fr.]           = SUM(BetragSoll)-SUM(BetragHaben)
FROM @tspGetKontoauszug T
  INNER JOIN FaLeistung LEI ON LEI.FaLeistungID = T.FaLeistungID
  INNER JOIN vwPerson PRS ON PRS.BaPersonID = LEI.BaPersonID
  INNER JOIN XUser USR ON USR.UserID = LEI.UserID
  
  OUTER APPLY (SELECT TOP 1 LAB.FaLeistungID, ABK.IkAbklaerungArtCode
               FROM FaLeistung LAB
                 INNER JOIN dbo.IkAbklaerung ABK ON ABK.FaLeistungID = LAB.FaLeistungID
               WHERE LAB.ModulID = 4
                 AND LAB.FaProzessCode = 400 --Abklärung
                 AND LAB.BaPersonID = LEI.BaPersonID
                 AND (@IkAbklaerungArt IS NULL OR ABK.IkAbklaerungArtCode = @IkAbklaerungArt) --es interessieren nur die Abklärungen der ausgewählten Art
               ORDER BY ABK.DatumAbklaerung, ABK.IkAbklaerungID DESC
               ) ABK
  
WHERE T.Einmalig = 1
GROUP BY USR.LogonName, LEI.IkRueckerstattungTypCode, ABK.IkAbklaerungArtCode;
</value>
  </data>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="edtZeitraumVon.Properties.Buttons" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAAAwAAAAQCAYAAAAiYZ4HAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8
        YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABMSURBVDhPYwABY2Pj/8RgsGIQgHFQBKEAqxyIQwyGKsdu
        MjrAqaGhgQErG6sGkAKYInSaOhpAYERrAAFkNk4NuACGBmIwVDkpgIEBAO2ojyYwtBe7AAAAAElFTkSu
        QmCC
</value>
  </data>
  <data name="edtZeitraumBis.Properties.Buttons" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAAAwAAAAQCAYAAAAiYZ4HAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8
        YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABMSURBVDhPYwABY2Pj/8RgsGIQgHFQBKEAqxyIQwyGKsdu
        MjrAqaGhgQErG6sGkAKYInSaOhpAYERrAAFkNk4NuACGBmIwVDkpgIEBAO2ojyYwtBe7AAAAAElFTkSu
        QmCC
</value>
  </data>
  <data name="edtUnterstuetzungsendeBis.Properties.Buttons" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAAAwAAAAQCAYAAAAiYZ4HAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8
        YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABMSURBVDhPYwABY2Pj/8RgsGIQgHFQBKEAqxyIQwyGKsdu
        MjrAqaGhgQErG6sGkAKYInSaOhpAYERrAAFkNk4NuACGBmIwVDkpgIEBAO2ojyYwtBe7AAAAAElFTkSu
        QmCC
</value>
  </data>
  <data name="edtUnterstuetzungsendeVon.Properties.Buttons" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAAAwAAAAQCAYAAAAiYZ4HAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8
        YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABMSURBVDhPYwABY2Pj/8RgsGIQgHFQBKEAqxyIQwyGKsdu
        MjrAqaGhgQErG6sGkAKYInSaOhpAYERrAAFkNk4NuACGBmIwVDkpgIEBAO2ojyYwtBe7AAAAAElFTkSu
        QmCC
</value>
  </data>
  <metadata name="$this.TrayHeight" type="System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>59</value>
  </metadata>
</root>