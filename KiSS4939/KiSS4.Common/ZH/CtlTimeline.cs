#region Header

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3053
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#endregion

using System;
using System.Collections.Generic;
using System.Drawing;
using System.Windows.Forms;
using KiSS4.Gui;

namespace KiSS4.Common.ZH
{
    public class CtlTimeline : KiSS4.Gui.KissComplexControl
    {
        #region Constants

        private const int heightForCaption = 25;
        private const int heightPerItem = 25;
        private const int verticalMargin = 5;

        #endregion

        #region Fields

        private Dictionary<int, KeyValuePair<string, SolidBrush>> colors = new Dictionary<int, KeyValuePair<string, SolidBrush>>();
        private DateTime dtFrom = DateTime.Today - new TimeSpan(1, 0, 0, 0);
        private DateTime dtTo = DateTime.Today;
        private readonly Font font = new Font("Arial", 8, FontStyle.Regular);
        private List<TimelineItem> items = new List<TimelineItem>();
        private List<KissLabel> labels = new List<KissLabel>();
        private readonly Pen pen = new Pen(Color.Black, 1);
        private readonly Pen penRed = new Pen(Color.Red, 2);
        private bool showToday = true;

        Color previousColor = Color.Black;
        Random random = new Random();

        #endregion

        #region Constructors

        public CtlTimeline()
        {
            this.InitializeComponent();

            this.DoubleBuffered = true;
            this.Paint += new System.Windows.Forms.PaintEventHandler(this.Timeline_Paint);
            this.SizeChanged += new System.EventHandler(this.Timeline_SizeChanged);
        }

        #endregion

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.SuspendLayout();
            //
            // CtlTimeline
            //
            this.BackColor = System.Drawing.Color.Transparent;
            this.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.Name = "CtlTimeline";
            this.Size = new System.Drawing.Size(313, 126);
            this.ResumeLayout(false);
        }

        #endregion

        #region Public Properties

        public IDictionary<int, KeyValuePair<string, SolidBrush>> Colors
        {
            get { return colors; }
        }

        public DateTime FromDate
        {
            get { return dtFrom; }
            set { dtFrom = value; }
        }

        public bool ShowToday
        {
            get { return showToday; }
            set { showToday = value; }
        }

        public DateTime ToDate
        {
            get { return dtTo; }
            set { dtTo = value; }
        }

        #endregion

        #region Public Methods

        public void AddItem(TimelineItem item)
        {
            items.Add(item);
            this.Height = items.Count * heightPerItem + heightForCaption;

            KissLabel label = new KissLabel();
            label.Left = 0;
            label.Margin = new Padding(10, 0, 0, 0);
            label.Top = (items.Count - 1) * heightPerItem;
            label.Height = heightPerItem;
            label.Text = item.Caption;
            label.LabelStyle = LabelStyleType.Custom;
            label.TextAlign = ContentAlignment.MiddleLeft;
            this.Controls.Add(label);
            this.labels.Add(label);
        }

        public void Clear()
        {
            this.Controls.Clear();
            this.labels.Clear();
            this.items.Clear();
            this.Invalidate();
        }

        public void GetBorderDates(out DateTime min, out DateTime max)
        {
            min = DateTime.Today;
            max = DateTime.Today;
            foreach (TimelineItem item in items)
            {
                foreach (TimelineSection section in item.Sections)
                {
                    min = section.FromDate < min ? section.FromDate : min;
                    max = section.FromDate > max ? section.FromDate : max;
                    max = section.ToDate != DateTime.MaxValue.Date && section.ToDate > max ? section.ToDate : max;
                }
            }
            //	if (max == DateTime.Today)
                max = max.AddYears(2);
            //	if (min == DateTime.Today)
                min = min.AddMonths(-6);
            if( max < min )
                max = min + new TimeSpan(1,0,0,0);
        }

        public void HighlightSection(DateTime from, DateTime to, List<int> ids, int highlightColorIndex)
        {
            HighlightSection(from, to, ids, highlightColorIndex, null, null);
        }

        public void HighlightSection(DateTime from, DateTime to, List<int> ids, int highlightColorIndex, int? mainID, int? mainHighlightColorIndex)
        {
            foreach(Label label in labels)
            {
                label.ForeColor = SystemColors.ControlText;
                label.BackColor = Color.Transparent;
            }

            foreach (TimelineItem item in items)
            {
                item.Background.Clear();
                if( mainID.HasValue && mainID.Value == item.ID && mainHighlightColorIndex.HasValue )
                {
                    item.Background.Add(new TimelineSection(from, to, mainHighlightColorIndex.Value));
                    labels[items.IndexOf(item)].BackColor = colors[mainHighlightColorIndex.Value].Value.Color;
                }
                else if (ids.Contains(item.ID))
                {
                    item.Background.Add(new TimelineSection(from, to, highlightColorIndex));
                    labels[items.IndexOf(item)].ForeColor = colors[highlightColorIndex].Value.Color;
                }
            }
            this.Invalidate();
        }

        #endregion

        #region Private Methods

        private Color RandomColor()
        {
            const float minD = 30f; // minimale Distanz zwischen den Farben
                Color color;
                float dHue; // differenz zwischen den Farbtönen
                do
                {
                    color = Color.FromArgb(random.Next(220), random.Next(220), random.Next(220));//256
                    float hue1 = color.GetHue(), hue2 = previousColor.GetHue();
                    dHue = hue1 - hue2;

                }
                while( dHue < minD || dHue > 360f - minD); // Eine Farbe wird nur akzeptiert, falls sie genügend verschiedenen Farbwert von der vorherigen hat
                return color;
        }

        private void Timeline_Paint(object sender, PaintEventArgs e)
        {
            try
            {
                SuspendLayout();
                int maxLabelWidth = 0;
                foreach (Label label in labels)
                {
                    int width = (int)(e.Graphics.MeasureString(label.Text, label.Font).Width);
                    maxLabelWidth = Math.Max(maxLabelWidth, width);
                }
                maxLabelWidth += 5;
                foreach (Label label in labels)
                    label.Width = maxLabelWidth;

                int daysToDisplay = ((TimeSpan)(dtTo - dtFrom)).Days;
                decimal pixelPerDay = (decimal)(this.Width - maxLabelWidth - 1) / daysToDisplay;
                int top = 0;

                List<DateTime> dates = new List<DateTime>();
                foreach (TimelineItem item in items)
                {
                    foreach (TimelineSection section in item.Sections)
                    {
                        DateTime dateFromDisplay = section.FromDate;
                        DateTime dateToDisplay = section.ToDate;
                        if (!dates.Contains(dateFromDisplay))
                            dates.Add(dateFromDisplay);
                        if (!dates.Contains(dateToDisplay))
                            dates.Add(dateToDisplay);
                    }
                }
                if (showToday)
                {
                    dates.Add(DateTime.Today);
                }
                dates.Sort();

                // Draw Background
                foreach (TimelineItem item in items)
                {
                    foreach (TimelineSection background in item.Background)
                    {
                        DateTime dateFromDisplay = (background.FromDate < dtFrom ? dtFrom : background.FromDate);
                        DateTime dateToDisplay = (background.ToDate > dtTo ? dtTo : background.ToDate);

                        int left = maxLabelWidth + (int)(((decimal)((TimeSpan)(dateFromDisplay - dtFrom)).Days) * pixelPerDay);
                        int width = maxLabelWidth + (int)decimal.Ceiling((((decimal)((TimeSpan)(dateToDisplay - dtFrom)).Days) * pixelPerDay)) - left;

                        e.Graphics.FillRectangle(colors[background.ColorCode].Value, left, top, width, heightPerItem);
                    }

                    top += heightPerItem;
                }

                // Legende
                const int captionOffset = 14;
                int legendTop = items.Count * heightPerItem;
                Dictionary<int, int> maxRightPerTopOffset = new Dictionary<int, int>();
                int maxOffset = 0;
                //System.Array knownColors = System.Drawing.KnownColor.GetValues();
                //currentColor = 0;
                Pen currentPen = new Pen(Color.Black, 1);
                SolidBrush currentBrush = new SolidBrush(Color.Black);
                foreach (DateTime date in dates)
                {
                    if (date >= DateTime.MaxValue.AddDays(-1.0) || dates.Contains(date + new TimeSpan(1, 0, 0, 0)))
                        continue;
                    currentPen.Color = RandomColor();
                    currentBrush.Color = currentPen.Color;
                    /*try
                    {
                        if (date == DateTime.MaxValue || dates.Contains(date + new TimeSpan(1, 0, 0, 0)))
                            continue;
                    }
                    catch { continue; }*/
                    if (date >= dtFrom && date <= dtTo)
                    {
                        string dateString = date.ToString("dd.MM.yy");
                        int position = maxLabelWidth + (int)(((decimal)((TimeSpan)(date - dtFrom)).Days) * pixelPerDay);
                        if (date == DateTime.Today)
                            dateString = "heute";
                        else
                            e.Graphics.DrawLine(currentPen, position, verticalMargin, position, legendTop + verticalMargin);
                        int captionWidth = (int)e.Graphics.MeasureString(dateString, font).Width;

                        // Move caption to fit into the timeline range
                        int left = Math.Min(position - captionWidth / 2, this.Width - captionWidth);
                        left = Math.Max(left, maxLabelWidth);
            /*
                        position = Math.Min(position, this.Width - captionWidth / 2);
                        position = Math.Max(position, maxLabelWidth + captionWidth / 2);
                        int left = position - captionWidth / 2 - 1;
            */
                        int offset;
                        for (offset = 0; offset < 100; offset += captionOffset)
                        {
                            maxOffset = Math.Max(maxOffset, offset);
                            if (!maxRightPerTopOffset.ContainsKey(offset) || maxRightPerTopOffset[offset] < left)
                                break;
                        }

                        maxRightPerTopOffset[offset] = left + captionWidth;
                        e.Graphics.DrawString(dateString, font, date == DateTime.Today ? Brushes.Red : currentBrush, left, legendTop + verticalMargin + offset);//Brushes.Black
                    }
                }
                this.Height = items.Count * heightPerItem + heightForCaption + maxOffset;

                // Today: red line
                if (showToday)
                {
                    int positionToday = maxLabelWidth + (int)(((decimal)((TimeSpan)(DateTime.Today - dtFrom)).Days) * pixelPerDay);
                    e.Graphics.DrawLine(penRed, positionToday, verticalMargin, positionToday, legendTop + verticalMargin);
                }

                top = 0;
                // Draw beams
                foreach (TimelineItem item in items)
                {
                    foreach (TimelineSection section in item.Sections)
                    {
                        DateTime dateFromDisplay = (section.FromDate < dtFrom ? dtFrom : section.FromDate);
                        DateTime dateToDisplay = (section.ToDate > dtTo ? dtTo : section.ToDate);
                        bool infinte = section.ToDate > dtTo;//section.ToDate == DateTime.MaxValue.Date;

                        int left = maxLabelWidth + (int)(((decimal)((TimeSpan)(dateFromDisplay - dtFrom)).Days) * pixelPerDay);
                        int width = maxLabelWidth + (int)decimal.Ceiling((((decimal)((TimeSpan)(dateToDisplay - dtFrom)).Days) * pixelPerDay)) - left;
                        if (infinte && width > 30)
                            width -= 18;

                        e.Graphics.FillRectangle(colors[section.ColorCode].Value, left, top + verticalMargin, width, heightPerItem - 2 * verticalMargin - 2);
                        e.Graphics.DrawRectangle(pen, left, top + verticalMargin, width, heightPerItem - 2 * verticalMargin - 2);

                        if (infinte)
                        {
                            const int firstGap = 3;
                            const int firstRect = 5;
                            const int secondGap = 3;
                            const int secondRect = 3;
                            e.Graphics.FillRectangle(colors[section.ColorCode].Value, left + width + firstGap, top + verticalMargin, firstRect, heightPerItem - 2 * verticalMargin - 2);
                            e.Graphics.DrawRectangle(pen, left + width + firstGap, top + verticalMargin, firstRect, heightPerItem - 2 * verticalMargin - 2);

                            e.Graphics.FillRectangle(colors[section.ColorCode].Value, left + width + firstGap + firstRect + secondGap, top + verticalMargin, secondRect, heightPerItem - 2 * verticalMargin - 2);
                            e.Graphics.DrawRectangle(pen, left + width + firstGap + firstRect + secondGap, top + verticalMargin, secondRect, heightPerItem - 2 * verticalMargin - 2);
                        }
                        string caption = colors[section.ColorCode].Key;
                        int captionWidth = (int)e.Graphics.MeasureString(caption, font).Width;
                        e.Graphics.DrawString(caption, font, Brushes.Black, left + (width - captionWidth) / 2 - 1, top + verticalMargin);
                    }
                    top += heightPerItem;
                }
            }
            finally
            {
                ResumeLayout();
            }
        }

        private void Timeline_SizeChanged(object sender, EventArgs e)
        {
            this.Invalidate();
        }

        #endregion
    }

    public class TimelineItem
    {
        #region Fields

        private List<TimelineSection> background = new List<TimelineSection>();
        private string caption;
        private int id;
        private List<TimelineSection> sections = new List<TimelineSection>();

        #endregion

        #region Constructors

        public TimelineItem(int id, string caption)
        {
            this.id = id;
            this.caption = caption;
        }

        #endregion

        #region Public Properties

        public IList<TimelineSection> Background
        {
            get { return background; }
        }

        public string Caption
        {
            get { return caption; }
            set { caption = value; }
        }

        public int ID
        {
            get { return id; }
            set { id = value; }
        }

        public IList<TimelineSection> Sections
        {
            get { return sections; }
        }

        #endregion
    }

    public partial class TimelineSection
    {
        #region Fields

        private int colorCode;
        private DateTime dtFrom;
        private DateTime dtTo;

        #endregion

        #region Constructors

        public TimelineSection(DateTime from, DateTime to, int colorCode)
        {
            this.dtFrom = from;
            this.dtTo = to;
            this.colorCode = colorCode;
        }

        #endregion

        #region Public Properties

        public int ColorCode
        {
            get { return colorCode; }
            set { colorCode = value; }
        }

        public DateTime FromDate
        {
            get { return dtFrom; }
            set { dtFrom = value; }
        }

        public DateTime ToDate
        {
            get { return dtTo; }
            set { dtTo = value; }
        }

        #endregion
    }
}